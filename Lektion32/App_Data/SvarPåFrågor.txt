Svar på frågor:

1. Klassen ansvarar för att:
	A. Representera en användare
	B. Spara/Uppdatera/Ta bort en användare (Dvs. EF-operationer för användare)
	C. Skicka Email till användare

Klassen bör endast ansvara för A. ovan. 

B. bör hanteras genom repo metoder, med anrop utanför klassen (ej i klassmetoder)
C. bör hanteras separat t.ex. i en EmailHelper-klass, med anrop utanför klassen (ej i klassmetoder)

3. En annan anledning är att Repository-klassen skall hantera andra Entities, som ej är garanterade att implementera en Email-property.

5. Om vi ersatt Repository<User> med UserRepository så hade programmet fungerat som tänkt och inga oönskade beteenden hade uppstått eftersom UserRepository ärver relevanta metoder från Repository<User> och alltså har samma implementation för dessa metoder.

Vi följer LSP eftersom vi kan ersätta Repository<User> med den ärvda typen UserRepository utan sidoeffekter.

6. Om vi hade ändrat implementationen av t.ex. Save()-metoden i UserRepository så att den inte sparar data så hade vi brutit mot LSP eftersom vi då inte hade kunnat ersätta Repository<User> med UserRepository utan oönskade sidoeffekter (I det här fallet att data inte sparas).

7. Implementationen bryter mot ISP eftersom vi har ett generellt interface som innehåller metoder som 

Problemen med detta är att vi får en massa onödig kod i de konkreta implementationerna (NotImplementedException-metoderna).

Det kan också se ut i intellisense som att en implementation stödjer t.ex. ExportToPDF när den i själva verket inte gör det. Detta kan potentiellt leda till runtime exceptions.

Interfacet förmedlar inte heller intentionen hos de olika konkreta implementationerna. T.ex. kanske det finns en god anledning att inte exportera en viss implementation till SQL - I den faktiska koden kan man få intrycket att intentionen är att det skall gå att exportera till SQL, men att det helt enkelt inte hunnits med ännu.